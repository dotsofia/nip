!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	M,module	/modules/
!_TAG_KIND_DESCRIPTION!C++	P,partition	/partitions/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/sofia/dev/nip/include/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/p6.1.20240825.0/
!_TAG_ROLE_DESCRIPTION!C++!header	exported	/exported with "exported imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!header	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C++!module	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!module	partOwner	/used for specifying a partition/
!_TAG_ROLE_DESCRIPTION!C++!partition	imported	/imported with "imported ..."/
ArgumentList	parser.h	/^    typedef std::vector<std::unique_ptr<Expr>> ArgumentList;$/;"	t	class:Parser	typeref:typename:std::vector<std::unique_ptr<Expr>>
Block	ast.h	/^    Block(SourceLocation location, std::vector<std::unique_ptr<Stmt>> statements) $/;"	f	struct:Block
Block	ast.h	/^struct Block : public Printable {$/;"	s
CallExpr	ast.h	/^    CallExpr(SourceLocation location,$/;"	f	struct:CallExpr
CallExpr	ast.h	/^struct CallExpr : public Expr {$/;"	s
Colon	lexer.h	/^    Colon  = single_char_tokens[5],$/;"	e	enum:TokenKind
Comma	lexer.h	/^    Comma  = single_char_tokens[7],$/;"	e	enum:TokenKind
Custom	ast.h	/^    enum class Kind { Void, Number, Custom };$/;"	e	enum:Type::Kind
Custom	ast.h	/^    static Type Custom(const std::string &name) { return {Kind::Custom, name}; }$/;"	f	struct:Type	typeref:typename:Type
Decl	ast.h	/^    Decl(SourceLocation location, std::string identifier) $/;"	f	struct:Decl
Decl	ast.h	/^struct Decl : public Printable {$/;"	s
DeclRefExpr	ast.h	/^    DeclRefExpr(SourceLocation location, std::string identifier)$/;"	f	struct:DeclRefExpr
DeclRefExpr	ast.h	/^struct DeclRefExpr : public Expr {$/;"	s
DecoratedBlock	ast.h	/^    DecoratedBlock(SourceLocation location,$/;"	f	struct:DecoratedBlock
DecoratedBlock	ast.h	/^struct DecoratedBlock : public Printable {$/;"	s
DecoratedCallExpr	ast.h	/^    DecoratedCallExpr(SourceLocation location,$/;"	f	struct:DecoratedCallExpr
DecoratedCallExpr	ast.h	/^struct DecoratedCallExpr : public DecoratedExpr {$/;"	s
DecoratedDecl	ast.h	/^    DecoratedDecl(SourceLocation location, DecoratedDecl &decl)$/;"	f	struct:DecoratedDeclRefExpr
DecoratedDecl	ast.h	/^    DecoratedDecl(SourceLocation, std::string identifier, Type type)$/;"	f	struct:DecoratedDecl
DecoratedDecl	ast.h	/^struct DecoratedDecl : public Printable {$/;"	s
DecoratedDeclRefExpr	ast.h	/^struct DecoratedDeclRefExpr : public DecoratedExpr {$/;"	s
DecoratedExpr	ast.h	/^struct DecoratedExpr : public DecoratedStmt {$/;"	s
DecoratedFunctionDecl	ast.h	/^    DecoratedFunctionDecl(SourceLocation location,$/;"	f	struct:DecoratedFunctionDecl
DecoratedFunctionDecl	ast.h	/^struct DecoratedFunctionDecl : public DecoratedDecl {$/;"	s
DecoratedNumberLiteral	ast.h	/^    DecoratedNumberLiteral(SourceLocation location, double value)$/;"	f	struct:DecoratedNumberLiteral
DecoratedNumberLiteral	ast.h	/^struct DecoratedNumberLiteral : public DecoratedExpr {$/;"	s
DecoratedParamDelc	ast.h	/^    DecoratedParamDelc(SourceLocation location, std::string identifier, Type type)$/;"	f	struct:DecoratedParamDelc
DecoratedParamDelc	ast.h	/^struct DecoratedParamDelc : public DecoratedDecl {$/;"	s
DecoratedReturnStmt	ast.h	/^    DecoratedReturnStmt(SourceLocation location,$/;"	f	struct:DecoratedReturnStmt
DecoratedReturnStmt	ast.h	/^struct DecoratedReturnStmt : public DecoratedStmt {$/;"	s
DecoratedStmt	ast.h	/^    DecoratedStmt(SourceLocation location)$/;"	f	struct:DecoratedStmt
DecoratedStmt	ast.h	/^    DecoratedStmt(SourceLocation location, Type type) $/;"	f	struct:DecoratedExpr
DecoratedStmt	ast.h	/^struct DecoratedStmt : public Printable {$/;"	s
Expr	ast.h	/^    Expr(SourceLocation location) : Stmt(location) {} $/;"	f	struct:Expr
Expr	ast.h	/^struct Expr : public Stmt {$/;"	s
FunctionDecl	ast.h	/^    FunctionDecl(SourceLocation location,$/;"	f	struct:FunctionDecl
FunctionDecl	ast.h	/^struct FunctionDecl : public Decl {$/;"	s
Identifier	lexer.h	/^    Identifier,$/;"	e	enum:TokenKind
Invalid	lexer.h	/^    Invalid = -128,$/;"	e	enum:TokenKind
KeywordFn	lexer.h	/^    KeywordFn,$/;"	e	enum:TokenKind
KeywordNumber	lexer.h	/^    KeywordNumber,$/;"	e	enum:TokenKind
KeywordReturn	lexer.h	/^    KeywordReturn,$/;"	e	enum:TokenKind
KeywordVoid	lexer.h	/^    KeywordVoid,$/;"	e	enum:TokenKind
Kind	ast.h	/^    enum class Kind { Void, Number, Custom };$/;"	g	struct:Type
LBrace	lexer.h	/^    LBrace = single_char_tokens[3], $/;"	e	enum:TokenKind
LParen	lexer.h	/^    LParen = single_char_tokens[1], $/;"	e	enum:TokenKind
Lexer	lexer.h	/^    Lexer(const SourceFile &src) : src(&src) {}$/;"	f	class:Lexer
Lexer	lexer.h	/^class Lexer {$/;"	c
Number	ast.h	/^    enum class Kind { Void, Number, Custom };$/;"	e	enum:Type::Kind
Number	ast.h	/^    static Type Number() { return {Kind::Number, "number"}; }$/;"	f	struct:Type	typeref:typename:Type
Number	lexer.h	/^    Number,$/;"	e	enum:TokenKind
NumberLiteral	ast.h	/^    NumberLiteral(SourceLocation location, std::string value)$/;"	f	struct:NumberLiteral
NumberLiteral	ast.h	/^struct NumberLiteral : public Expr {$/;"	s
ParamDecl	ast.h	/^    ParamDecl(SourceLocation location, std::string identifier, Type type)$/;"	f	struct:ParamDecl
ParamDecl	ast.h	/^struct ParamDecl : public Decl {$/;"	s
ParameterList	parser.h	/^    typedef std::vector<std::unique_ptr<ParamDecl>> ParameterList;$/;"	t	class:Parser	typeref:typename:std::vector<std::unique_ptr<ParamDecl>>
Parser	parser.h	/^    Parser(Lexer &lexer)$/;"	f	class:Parser
Parser	parser.h	/^class Parser {$/;"	c
Printable	utility.h	/^struct Printable {$/;"	s
RBrace	lexer.h	/^    RBrace = single_char_tokens[4], $/;"	e	enum:TokenKind
RParen	lexer.h	/^    RParen = single_char_tokens[2], $/;"	e	enum:TokenKind
ReturnStmt	ast.h	/^    ReturnStmt(SourceLocation location, std::unique_ptr<Expr> expr = nullptr)$/;"	f	struct:ReturnStmt
ReturnStmt	ast.h	/^struct ReturnStmt : public Stmt {$/;"	s
Scope	semantic.h	/^        Scope(Semantic &sema) : sema(sema) { sema->scopes.emplace_back(); }$/;"	f	class:Semantic::Scope
Scope	semantic.h	/^    class Scope {$/;"	c	class:Semantic
Semantic	semantic.h	/^class Semantic {$/;"	c
SemiColon	lexer.h	/^    SemiColon = single_char_tokens[6],$/;"	e	enum:TokenKind
SourceFile	utility.h	/^struct SourceFile {$/;"	s
SourceLocation	utility.h	/^struct SourceLocation {$/;"	s
Stmt	ast.h	/^    Stmt(SourceLocation location) : location(location) {}$/;"	f	struct:Stmt
Stmt	ast.h	/^struct Stmt : public Printable {$/;"	s
Token	lexer.h	/^struct Token {$/;"	s
TokenKind	lexer.h	/^enum class TokenKind : char {$/;"	g	typeref:typename:char
Type	ast.h	/^    Type(Kind kind, std::string name) : kind(kind), name(std::move(name)) {}$/;"	f	struct:Type
Type	ast.h	/^struct Type {$/;"	s
Void	ast.h	/^    enum class Kind { Void, Number, Custom };$/;"	e	enum:Type::Kind
Void	ast.h	/^    static Type Void() { return {Kind::Void, "void"}; }$/;"	f	struct:Type	typeref:typename:Type
_EOF	lexer.h	/^    _EOF = single_char_tokens[0],$/;"	e	enum:TokenKind
_NIP_AST_H	ast.h	/^#define _NIP_AST_H$/;"	d
_NIP_DAST_H	dast.h	/^#define _NIP_DAST_H$/;"	d
_NIP_LEXER_H_	lexer.h	/^#define _NIP_LEXER_H_$/;"	d
_NIP_PARSER_H	parser.h	/^#define _NIP_PARSER_H$/;"	d
_NIP_UTILITY_H	utility.h	/^#define _NIP_UTILITY_H$/;"	d
_SEMANTIC_NIP_H	semantic.h	/^#define _SEMANTIC_NIP_H$/;"	d
advance	lexer.h	/^    char advance() {$/;"	f	class:Lexer	typeref:typename:char
advance	parser.h	/^    void advance() { next_token = lexer->get_next_token(); }$/;"	f	class:Parser	typeref:typename:void
arguments	ast.h	/^    std::vector<std::unique_ptr<DecoratedExpr>> arguments;$/;"	m	struct:DecoratedCallExpr	typeref:typename:std::vector<std::unique_ptr<DecoratedExpr>>
arguments	ast.h	/^    std::vector<std::unique_ptr<Expr>> arguments;$/;"	m	struct:CallExpr	typeref:typename:std::vector<std::unique_ptr<Expr>>
ast	semantic.h	/^    std::vector<std::unique_ptr<FunctionDecl>> ast;$/;"	m	class:Semantic	typeref:typename:std::vector<std::unique_ptr<FunctionDecl>>
body	ast.h	/^    std::unique_ptr<Block> body;$/;"	m	struct:FunctionDecl	typeref:typename:std::unique_ptr<Block>
body	ast.h	/^    std::unique_ptr<DecoratedBlock> body;$/;"	m	struct:DecoratedFunctionDecl	typeref:typename:std::unique_ptr<DecoratedBlock>
buffer	utility.h	/^    std::string buffer;$/;"	m	struct:SourceFile	typeref:typename:std::string
callee	ast.h	/^    const DecoratedFunctionDecl *callee;  $/;"	m	struct:DecoratedCallExpr	typeref:typename:const DecoratedFunctionDecl *
callee	ast.h	/^    std::unique_ptr<Expr> callee;$/;"	m	struct:CallExpr	typeref:typename:std::unique_ptr<Expr>
col	lexer.h	/^    int col = 0;$/;"	m	class:Lexer	typeref:typename:int
col	utility.h	/^    int col;$/;"	m	struct:SourceLocation	typeref:typename:int
decl	ast.h	/^    const DecoratedDecl *decl;$/;"	m	struct:DecoratedDeclRefExpr	typeref:typename:const DecoratedDecl *
dump	ast.h	/^    void dump(size_t level = 0) const override {$/;"	f	struct:DecoratedFunctionDecl	typeref:typename:void
dump	ast.h	/^    void dump(size_t level = 0) const override {$/;"	f	struct:DecoratedNumberLiteral	typeref:typename:void
expr	ast.h	/^    std::unique_ptr<DecoratedExpr> expr;$/;"	m	struct:DecoratedReturnStmt	typeref:typename:std::unique_ptr<DecoratedExpr>
expr	ast.h	/^    std::unique_ptr<Expr> expr;$/;"	m	struct:ReturnStmt	typeref:typename:std::unique_ptr<Expr>
file_path	utility.h	/^    std::string_view file_path;$/;"	m	struct:SourceLocation	typeref:typename:std::string_view
i	lexer.h	/^    size_t i = 0; $/;"	m	class:Lexer	typeref:typename:size_t
identifier	ast.h	/^    std::string identifier;$/;"	m	struct:Decl	typeref:typename:std::string
identifier	ast.h	/^    std::string identifier;$/;"	m	struct:DeclRefExpr	typeref:typename:std::string
identifier	ast.h	/^    std::string identifier;$/;"	m	struct:DecoratedDecl	typeref:typename:std::string
indent	utility.h	/^    std::string indent(size_t level) const {$/;"	f	struct:Printable	typeref:typename:std::string
is_ast_incomplete	parser.h	/^    bool is_ast_incomplete = false; \/\/ AST may be incomplete and we need to report back or rec/;"	m	class:Parser	typeref:typename:bool
keywords	lexer.h	/^const std::unordered_map<std::string_view, TokenKind> keywords = {$/;"	v	typeref:typename:const std::unordered_map<std::string_view,TokenKind>
kind	ast.h	/^    Kind kind;$/;"	m	struct:Type	typeref:typename:Kind
kind	lexer.h	/^    TokenKind kind;$/;"	m	struct:Token	typeref:typename:TokenKind
lexer	parser.h	/^    Lexer *lexer;$/;"	m	class:Parser	typeref:typename:Lexer *
line	lexer.h	/^    int line = 1;$/;"	m	class:Lexer	typeref:typename:int
line	utility.h	/^    int line;$/;"	m	struct:SourceLocation	typeref:typename:int
location	ast.h	/^    SourceLocation location;$/;"	m	struct:Block	typeref:typename:SourceLocation
location	ast.h	/^    SourceLocation location;$/;"	m	struct:Decl	typeref:typename:SourceLocation
location	ast.h	/^    SourceLocation location;$/;"	m	struct:DecoratedBlock	typeref:typename:SourceLocation
location	ast.h	/^    SourceLocation location;$/;"	m	struct:DecoratedDecl	typeref:typename:SourceLocation
location	ast.h	/^    SourceLocation location;$/;"	m	struct:DecoratedStmt	typeref:typename:SourceLocation
location	ast.h	/^    SourceLocation location;$/;"	m	struct:Stmt	typeref:typename:SourceLocation
location	lexer.h	/^    SourceLocation location;$/;"	m	struct:Token	typeref:typename:SourceLocation
match	utility.h	/^#define match(/;"	d
name	ast.h	/^    std::string name;$/;"	m	struct:Type	typeref:typename:std::string
next_token	parser.h	/^    Token next_token;$/;"	m	class:Parser	typeref:typename:Token
params	ast.h	/^    std::vector<std::unique_ptr<DecoratedParamDecl>> params;$/;"	m	struct:DecoratedFunctionDecl	typeref:typename:std::vector<std::unique_ptr<DecoratedParamDecl>>
params	ast.h	/^    std::vector<std::unique_ptr<ParamDecl>> params;$/;"	m	struct:FunctionDecl	typeref:typename:std::vector<std::unique_ptr<ParamDecl>>
path	utility.h	/^    std::string_view path;$/;"	m	struct:SourceFile	typeref:typename:std::string_view
peek	lexer.h	/^    char peek() const { return src->buffer[i]; }$/;"	f	class:Lexer	typeref:typename:char
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:Block	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:CallExpr	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:DeclRefExpr	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:DecoratedBlock	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:DecoratedCallExpr	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:DecoratedDeclRefExpr	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:DecoratedParamDelc	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:DecoratedReturnStmt	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:FunctionDecl	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:NumberLiteral	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:ParamDecl	typeref:typename:void
print	ast.h	/^    void print(size_t level = 0) const override {$/;"	f	struct:ReturnStmt	typeref:typename:void
scope	semantic.h	/^typedef std::vector<DecorateDecl *> scope; $/;"	t	typeref:typename:std::vector<DecorateDecl * >
scopes	semantic.h	/^    std::vector<scope> scopes;$/;"	m	class:Semantic	typeref:typename:std::vector<scope>
sema	semantic.h	/^        Semantic *sema;$/;"	m	class:Semantic::Scope	typeref:typename:Semantic *
single_char_tokens	lexer.h	/^constexpr char single_char_tokens[] = {'\\0', '(', ')', '{', '}', ':', ';', ','};$/;"	v	typeref:typename:char[]
src	lexer.h	/^    const SourceFile *src;$/;"	m	class:Lexer	typeref:typename:const SourceFile *
statements	ast.h	/^    std::vector<std::unique_ptr<DecoratedStmt>> statements;$/;"	m	struct:DecoratedBlock	typeref:typename:std::vector<std::unique_ptr<DecoratedStmt>>
statements	ast.h	/^    std::vector<std::unique_ptr<Stmt>> statements;$/;"	m	struct:Block	typeref:typename:std::vector<std::unique_ptr<Stmt>>
store_result	utility.h	/^#define store_result(/;"	d
synchronize_on	parser.h	/^    void synchronize_on(TokenKind kind) {$/;"	f	class:Parser	typeref:typename:void
type	ast.h	/^    Type type;$/;"	m	struct:DecoratedDecl	typeref:typename:Type
type	ast.h	/^    Type type;$/;"	m	struct:DecoratedExpr	typeref:typename:Type
type	ast.h	/^    Type type;$/;"	m	struct:FunctionDecl	typeref:typename:Type
type	ast.h	/^    Type type;$/;"	m	struct:ParamDecl	typeref:typename:Type
value	ast.h	/^    double value;$/;"	m	struct:DecoratedNumberLiteral	typeref:typename:double
value	ast.h	/^    std::string value;$/;"	m	struct:NumberLiteral	typeref:typename:std::string
value	lexer.h	/^    std::optional<std::string> value = std::nullopt;$/;"	m	struct:Token	typeref:typename:std::optional<std::string>
~Scope	semantic.h	/^        ~Scope() { sema->scopes.pop_back(); }$/;"	f	class:Semantic::Scope
